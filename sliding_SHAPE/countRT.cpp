
#include "sliding_shape.h"
#include "version.h"

#define WARNING "The input tab file must be sorted (generated by sam2tab)"

void print_usage()
{
    char buff[2000];
    const char *help_info = 
            "countRT - count RT and BD\n"
            "=============================================================\n"
            "\e[1mUSAGE:\e[0m\n"
            "\tcountRT -in input1.tab,input2.tab... -size chrSizeFile [-ijf junctionFile] -out outputFile\n"
            "\e[1mHELP:\e[0m\n"
            "\t-in: tab file generated by sam2tab, multiple files seperated by comma \n"
            "\t-size: input a chromosome size file generated by STAR (chrNameLength.txt) \n"
            "\t-ijf: input a junction file generated by STAR (sjdbList.fromGTF.out.tab)\n"
            "\t-ojf: output a junction file with sopported reads\n"
            "\t-omc: minimul DMSO BD for output (default: 50)\n"
            "\t-out: output RT and BD\n\n"

            "\e[1mWARNING:\e[0m\n\t%s\n"
            "\e[1mVERSION:\e[0m\n\t%s\n"
            "\e[1mLIB VERSION:\e[0m\n\t%s\n"
            "\e[1mDATE:\e[0m\n\t%s\n"
            "\e[1mAUTHOR:\e[0m\n\t%s\n";

    ostringstream warning;
    warning << YELLOW << WARNING << DEF;

    sprintf(buff, help_info, warning.str().c_str(), BINVERSION, LIBVERSION, DATE, "Li Pan");
    cout << buff << endl;
}

struct Param
{
    StringArray inputFiles;
    string outputFile;

    string size_file;
    string junction_file;
    string out_junc_file;

    uINT out_min_cov = 50;

    operator bool()
    {
        if(inputFiles.size() == 0)
        {
            cerr << RED << "Please specify -in" << DEF << endl;
            return false;
        }
        if(outputFile.empty() or size_file.empty())
        {
            cerr << RED << "Please specify -size -out" << DEF << endl;
            return false;
        }
        return true;
    }
};

void has_next(int argc, int current)
{
    if(current + 1 >= argc)
    {
        cerr << RED << "FATAL ERROR: Parameter Error" << DEF << endl;
        print_usage();
        exit(-1);
    }
}

Param read_param(int argc, char *argv[])
{
    Param param;

    if(argc <= 1)
    {
        print_usage();
        exit(-1);
    }

    for(int i=1; i<argc; i++)
    {
        if( argv[i][0] == '-' )
        {
            if(not strcmp(argv[i]+1, "in"))
            {
                has_next(argc, i);
                split(argv[i+1], ',', param.inputFiles);
                i++;
            }else if(not strcmp(argv[i]+1, "out"))
            {
                has_next(argc, i);
                param.outputFile = argv[i+1];
                i++;
            }else if(not strcmp(argv[i]+1, "size"))
            {
                has_next(argc, i);
                param.size_file = argv[i+1];
                i++;
            }else if(not strcmp(argv[i]+1, "ijf"))
            {
                has_next(argc, i);
                param.junction_file = argv[i+1];
                i++;
            }else if(not strcmp(argv[i]+1, "ojf"))
            {
                has_next(argc, i);
                param.out_junc_file = argv[i+1];
                i++;
            }else if(not strcmp(argv[i]+1, "omc"))
            {
                has_next(argc, i);
                param.out_min_cov = stoul(argv[i+1]);
                i++;
            }else{
                cerr << RED << "FATAL ERROR: unknown option: " << argv[i] << DEF << endl;
                print_usage();
                exit(-1);
            }
        }else{
            cerr << RED << "FATAL ERROR: unknown option: " << argv[i] << DEF << endl;
            print_usage();
            exit(-1);
        }
    }
    return param;
}

void write_RTBD(ofstream &OUT, const string &chr_id_strand, vector<uIntArray> &rt_Array, vector<uIntArray> &bd_Array, const uINT min_D)
{
    const uLONG cSize = bd_Array.front().size() - 1;

    if(rt_Array.size() != bd_Array.size())
    {
        cerr << RED << "FATAL Error: rt_Array and bd_Array different length" << DEF << endl;
        exit(-1);
    }

    string chr_id = chr_id_strand.substr(0, chr_id_strand.size()-1);
    char strand = chr_id_strand.back();

    for(uLONG i=1; i<=cSize; i++)
    {
        //clog << i << endl;
        if( any_of(rt_Array.begin(), rt_Array.end(), [&i](uIntArray &a){return a[i]>=1;}) or 
            any_of(bd_Array.begin(), bd_Array.end(), [&i, &min_D](uIntArray &a){return a[i]>=min_D;}) )
        {
            OUT << chr_id << "\t" << strand << "\t" << i;
            for(uLONG j=0; j<rt_Array.size(); j++)
            {
                OUT << "\t" << rt_Array[j][i] << "\t" <<  bd_Array[j][i];
            }
            OUT << "\n";
        }
    }
}

int main(int argc, char *argv[])
{

    Param param = read_param(argc, argv);

    if(not param)
    {
        print_usage();
        exit(-1);
    }

    MapStringT<JunctionArray> junctions;
    MapStringuLONG chr_size;

    clog << "load_chr_size..." << endl;
    load_chr_size(param.size_file, chr_size);

    if(param.junction_file.empty())
    {
        cerr << RED << "Waning: no junction file given" << DEF << endl;
    }else{
        clog << "load_junctions..." << endl;
        load_junctions(param.junction_file, junctions, chr_size);
    }

    clog << "Start to init input handles..." << endl;
    vector<ifstream *> i_vec;
    for(string fn: param.inputFiles)
    {
        i_vec.push_back( new ifstream(fn, ifstream::in) );
        check_input_handle(*i_vec.back(), fn);
    }

    StringArray chr_ids(i_vec.size());
    vector< vector<Map_Record> > record_array(i_vec.size());

    ofstream OUT(param.outputFile, ofstream::out);

    uLONG index = 0;
    while(sync_chrs(i_vec, chr_ids, record_array))
    {

        const string chr_id = chr_ids[0];
        if(chr_size.find(chr_id) == chr_size.end())
        {
            cerr << RED << "Warning: " << chr_id << " not found on size file" << DEF << endl;
            continue;
        }

        if(junctions.find(chr_id) == junctions.end())
        {
            cerr << RED << "Warning: " << chr_id << " junction not found" << DEF << endl;
            junctions[chr_id];
        }

        if(junctions[chr_id].size() > 0)
        {
            clog << "Start to build_junction_support" << endl;
            for(vector<Map_Record> &a: record_array)
                build_junction_support(a, junctions.at(chr_id));

            clog << "Start to combine_junction" << endl;
            combine_junction(junctions[chr_id]);

            clog << "Start to check_overlap" << endl;
            check_overlap(junctions[chr_id], chr_size.at(chr_id));
        }

        clog << index++ <<  ". read_chr " << chr_id << "\t" << chr_size.at(chr_id) << endl;

        const uLONG cSize = chr_size.at(chr_id);
        
        vector<uIntArray> rt_array(i_vec.size());
        for(uIntArray &a: rt_array)
            a.assign(cSize+1, 0);
        
        vector<uIntArray> bd_array(i_vec.size());
        for(uIntArray &a: bd_array)
            a.assign(cSize+1, 0);

        const uLONG binsize = 1000000;

        FloatArray score(cSize+1, null);

        if(record_array.front().front().strand == POS)
        {
            clog << "Start to calc_chr_BDRT_Pos" << endl;
            for(uLONG i=0; i<i_vec.size(); i++)
            {
                uLONG BD_ext = 0;
                calc_chr_BDRT_Pos(bd_array.at(i), rt_array.at(i), record_array.at(i), junctions[chr_id], cSize, BD_ext, binsize);
            }
        }
        else
        {
            clog << "Start to calc_chr_BDRT_Neg" << endl;
            for(uLONG i=0; i<i_vec.size(); i++)
            {
                uLONG BD_ext = 0;
                calc_chr_BDRT_Neg(bd_array.at(i), rt_array.at(i), record_array.at(i), junctions[chr_id], cSize, BD_ext, binsize);
            }
        }

        clog << "Start to write_RTBD: " << chr_id << endl;
        write_RTBD(OUT, chr_id, rt_array, bd_array, param.out_min_cov);

        clog << " Finish " << chr_id << endl;
    }

    for(uLONG i=0; i<i_vec.size(); i++)
    {
        i_vec[i]->close();
        delete i_vec[i];
    }

    if(not param.out_junc_file.empty())
    {
        clog << "write_junctions" << endl;
        write_junctions(junctions, param.out_junc_file);
    }
}


